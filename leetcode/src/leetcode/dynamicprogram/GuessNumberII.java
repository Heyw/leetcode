package leetcode.dynamicprogram;


/**
 * 给定一个范围0到n，然后让猜指定的一个数，如果猜错了，就需要给钱，该值等于猜错数的值，同时会提示目标数会比猜错数大还是小，直到猜对为止
 * 求最小需要准备多少钱能保证猜对该数
 * 因为这涉及到最小最大问题（MinMax），所以不能用二分查找法，二分查找只能找到最少步数
 *  任意一个数a都会存在另外一个数b的左边或者右边区域，猜数b左侧或者右侧大小都是同等的，
 *  因此为了保证能猜对数a，固然要选择花费较大的那一侧，因为这样才能保证无论猜测那一侧都能保证拥有足够的钱来猜对该数 
 *  另外又因为从[i...j]中猜出a，每个数都可能成为数b，因此需要一个变量min来保证从什么地方开始选择b才能保证最少花费
 *  在相邻两个数之间猜出另外一个数，选择较少的一方，这样即使第一次猜错了，第二次也可以猜对
 *  用动态规划来保存中间计算，减少计算量，dp[i][j]表示从i到j找到某个数所需花费最少的金额
 *  dp[i][i]=0;d[i][i+1]=i;
 *  数据推演过程：[1,2,3]=2,如果小于或者大于都可以准确猜出下一个数
 *  [1,2,3,4]:现在[1,2,3]中猜2，猜错了赔2，再在[3,4]或者[1]中猜，最多赔2+3=5，先在[2,3,4]中猜，猜错了最多赔3，然后再在[1,2]或者[4]中猜，猜错了最多赔dp[1,2]+3，故最少的配法为4
 *  [2,3,4,5]:dp[2,4]=3,dp[3,5]=4,则dp[2,5]=Min{3+dp[4,5],4+dp[2,3]}={3+4,4+2}=6
 *  [1,2,3,4,5]:dp[1,5]=Min{4+dp[5,5]+dp[1,3],3+dp[4,5]+dp[1,2],2+dp[3,5]+dp[1,1]}=6
 * @author Administrator
 *
 */
public class GuessNumberII {
	/**
	 * 给定一个范围0到n，然后让猜指定的一个数，如果猜错了，就需要给钱，该值等于猜错数的值，同时会提示目标数会比猜错数大还是小，直到猜对为止
	 * 求最小需要准备多少钱能保证猜对该数
	 * 因为这涉及到最小最大问题（MinMax），所以不能用二分查找法，二分查找只能找到最少步数
	 *  任意一个数a都会存在另外一个数b的左边或者右边区域，猜数b左侧或者右侧大小都是同等的，
	 *  因此为了保证能猜对数a，固然要选择花费较大的那一侧，因为这样才能保证无论猜测那一侧都能保证拥有足够的钱来猜对该数 
	 *  另外又因为从[i...j]中猜出a，每个数都可能成为数b，因此需要一个变量min来保证从什么地方开始选择b才能保证最少花费
	 *  在相邻两个数之间猜出另外一个数，选择较少的一方，这样即使第一次猜错了，第二次也可以猜对
	 *  用动态规划来保存中间计算，减少计算量，dp[i][j]表示从i到j找到某个数所需花费最少的金额
	 *  dp[i][i]=0;d[i][i+1]=i;
	 *  数据推演过程：[1,2,3]=2,如果小于或者大于都可以准确猜出下一个数
	 *  [1,2,3,4]:现在[1,2,3]中猜2，猜错了赔2，再在[3,4]或者[1]中猜，最多赔2+3=5，先在[2,3,4]中猜，猜错了最多赔3，然后再在[1,2]或者[4]中猜，猜错了最多赔dp[1,2]+3，故最少的配法为4
	 *  [2,3,4,5]:dp[2,4]=3,dp[3,5]=4,则dp[2,5]=Min{3+dp[4,5],4+dp[2,3]}={3+4,4+2}=6
	 *  [1,2,3,4,5]:dp[1,5]=Min{4+dp[5,5]+dp[1,3],3+dp[4,5]+dp[1,2],2+dp[3,5]+dp[1,1]}=6
	 * @author Administrator
	 *
	 */
		public int getMoneyAmount(int n) {
		        int[][] dp=new int[n+1][n+1];
		        //[1,n]之间计算时需要计算[1,n-1],[2,n-1],以及中间[i,j],j是不断变化的
		        for(int j=2;j<n+1;j++){//j代表右边界
		        	for(int i=j-1;i>0;i--){//i代表左边界
		        		int min=Integer.MAX_VALUE;
		        		for(int k=i+1;k<j;k++){//k代表左右边界中间值
		        			min=Math.min(min, k+Math.max(dp[i][k-1],dp[k+1][j] ));
		        		}
		        		dp[i][j]=(i+1==j?i:min);
		        	}
		        }
		        return dp[1][n];
		    }
		public static void main(String[] args) {
			System.out.println(new GuessNumberII().getMoneyAmount(4));
		}
}
